# Automatic Document Generation


## Figures

The notation for including figures uses the... ```figure``` environment. 
To display figures, you need to declare the ```graphicx``` package in the preamble 
of the markup script (before the ```\begin{document}``` command). 
Depending on the platform, you might also have to specify how to
translate images in ```eps``` format into ```pdf``` format. 
Using ```eps``` figures is worthwhile because they contain text code for making quick adjustments and the images are rendered more clearly, since
no translation of the images is required. 
To handle cases on different platforms, you can use ```if``` statements, 
much like you can in other languages. 


We add a figure to a script called ```Paper_2.tex```.

```
\documentclass[11pt]{article}

\ifx\pdftexversion\undefined
    \usepackage[dvips]{graphicx}
\else
    \usepackage[pdftex]{graphicx}
    \usepackage{epstopdf}
    \epstopdfsetup{suffix=}
\fi

\begin{document}
This is my document.

In Figure \ref{fig:example}, there is an image. 

\begin{figure}
\centering
\includegraphics[width=\textwidth]{../Figures/name_of_figure.eps}
\caption{Caption Goes Here}
\label{fig:example}
\end{figure}

\end{document}
```

### Code Snippets

You can also display the commands you used to generate some output, 
which might be useful to help explain your analysis.
Inline commands can be displayed with the ```\texttt``` command, 
as in
```
\texttt{my_function(argument_1)}
```
which will display the text inline in a monospaced (typewriter) font. 
This is fine for short comments but not well-suited f
or large blocks of code.
There exists two common approaches to display code blocks
in documents generated by LaTeX: 
the ```verbatim``` environment
and an environment specifically designed for
displaying computer code. 

#### ```verbatim```

The verbatim environment displays text 
exactly as it is entered--verbatim. 
It will render the exact same alphanumeric characters that 
you enter between the commands 
```\begin{verbatim}``` and ```\end{verbatim}```, 
including any special characters that would normally
execute commands in LaTeX.


```
\begin{verbatim}
R> # Generate a random variable.
R> epsilon <- rnorm(1000)
\end{verbatim}
```

This method is fine to get the message across but it 
is not specifically designed for displaying computer code.


#### ```listings```

Another approach is to invoke an environment
specifically designed for displaying code.
One example is the ```listings``` environment. 
This is not a standard environment in LaTeX, 
so you must first declare that you will be 
using this package, much like you would for 
an R package or a Python module. 


In addition, it is better to declare a few more packages 
in the preamble before the ```\begin{document}``` command. 

```
% Packages for displaying code:
\usepackage{listings}
\usepackage{textcomp}
\usepackage{color}

% Color settings used in the code below:
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% Settings for the formatting of the code on display:
\lstset{frame=tb,
  language=R,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
```
The first is the set of packages to display code, 
the main one being ```listings```. 
The rest are for customized settings, such as the color
and format of the syntax within the code.
This is designed for syntax highlighting, 
just as with a text editor 
designed for software development,
and can be set with for the particular programming language.

A block of R code is displayed with the following commands.

```
\begin{lstlisting}[language=R]
R> # Generate a random variable.
    epsilon <- rnorm(1000)
\end{lstlisting}
```

The script ```my_script.R``` in the ```Code``` folder 
follows this command with the following commands. 

```
# Plot a histogram.
fig_ext <- 'eps'
fig_dir <- 'Figures'
fig_file_name <- sprintf('name_of_figure.%s', fig_ext)
out_file_name <- sprintf('%s/%s', fig_dir, fig_file_name)

setEPS()
postscript(out_file_name)

hist(epsilon, col = 'blue')

dev.off()
```

This generates a figure ```name_of_figure.eps``` and saves it
in the ```Figures``` folder. 
This is all collected to create a document displaying the figure
in the script ```Paper_w_Figure.tex```, 
located in the ```Paper``` folder. 
Run ```DoWork.sh``` to execute the R script, 
generate the figure and build the pdf document
in the ```Paper``` folder. 


